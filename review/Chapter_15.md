1. 把下面的十进制数转换为二进制数:
（十进制整数到二进制数据的转换通常使用除以2取余的方法，在不够位数的情况下可以在前面补0。）
a. 3:        0000 0011
b. 13:       0000 1101
c. 59:       0011 1011
d. 119:      0111 0111

2. 将下面的二进制值转换为十进制、八进制和十六进制的形式:
（二进制 to 十进制：直接将位值相加）
（二进制 to 八进制：从右向左，3位二进制一组进行转换）
（二进制 to 十六进制：从右向左，4位二进制彝族进行转换）
a. 00010101:         21(D)       25(O)       0x15(H)
b. 01010101:         85(D)       125(O)      0x55(H)
c. 01001100:         76(D)       114(O)      0x4C(H)
d. 10011101:         157(D)      235(O)      0x9D(H)

3. 对下面的表达式求值，假设每个值都为8位：
a. ~3:               十进制 3 按位取反       ～(0000 0011)，得到结果 1111 1100，即 252。
b. 3 & 6:            按位与运算              (0000 0011) & (0000 0110)，得到结果 0000 0010, 即 2。
c. 3 | 6:            按位或运算              (0000 0011) | (0000 0110)，得到结果 0000 0111，即 7。
d. 1 | 6:            按位或运算              (0000 0001) | (0000 0110)，得到结果 0000 0111，即 7。
e. 3 ^ 6:            按位异或运算            (0000 0011) | (0000 0110)，得到结果 0000 0101，即 5。
f. 7 >> 1:           右移位运算              (0000 0111) >> 1，得到结果 0000 0011，即 3。
g. 7 << 2:           左移位运算              (0000 0111) << 2，得到结果 0001 1100，即 28。

4. 对下面的表达式求值，假设每个值都为8位：
a. ~0:              对 0 按位取反           得到 1111 1111，即十进制 255。
b. !0:              对 0（假） 取反即为真           值为 1（真）。
c. 2 & 4:           按位与运算              (0000 0010) & (0000 0100)，得到结果 0000 0000，即 0。
d. 2 && 4:          && 逻辑与运算，2、4均为真（非0）        得到结果 1（真）
e. 2 | 4:           按位或运算              (0000 0010) & (0000 0100)，得到结果 0000 0110，即 6。
f. 2 || 4:          || 逻辑或运算，2、4均为真（非0）        得到结果 1（真）
g. 5 << 3:          左移位运算              (0000 0101) << 3，得到结果 0010 1000，即 40。

5. 因为 ASCII 码只使用最后 7 位，所以有时需要用掩码关闭其他位，其相应的二进制掩码是什么？分别用十进制、八进制和十六进制来表示这个掩码。

掩码：通过二进制的位操作隐藏或关闭某些数位上的数据，ASCII 码只使用后 7 位，最高位保留不用。
因此其掩码只需要使最高位为 0，其余位为 1,即用(0111 1111) 表示，这样可以在按位与操作（使用掩码）中，隐藏最高位，保留其他位的数值。
转换成其他进制分别是 127(D)、177(O)、0x7F(H)。

6. 程序清单 15.2 中，把下面的代码
```c
while (bits-- > 0)
{
    mask |= bitval;
    bitval <<= 1;
}
```
替换成以下内容后，程序照常工作
```c
while (bits-- > 0)
{
    mask += bitval;
    bitval *= 2;
}
```
这是否意味着 *= 2 等同于 <<= 1？+= 是否等同于 |= ？

移位运算等价于快速的乘法、除法运算，其中左移 n 位等价于乘以 2 的 n 次幂；右移 n 位等价于除以 2 的 n 次幂（被移位数非负）。因此，*= 2 等同于 <<= 1。
但是，+= 不同于 |=。二者只能在没有相同位数相等时才结果相同，即本质上，|= 不会产生进位效果。

7. a. Tinkerbell 有一个可读取到程序中的硬件字节。该字节包括以下信息：

| 位   | 含义                   |
| ---- | ---------------------- |
| 0～1 | 1.4MB 软盘驱动器的数量 |
| 2    | 未使用                 |
| 3～4 | CD-ROM 驱动器的数量    |
| 5    | 未使用                 |
| 6～7 | 硬盘驱动器的数量       |

Tinkerbell 计算机和 IBM PC 一样，从右往左填充结构位字段。创建一个适合存放这些信息的位字段模板。

b. Klinkerbell 计算机与 Tinkerbell 计算机类似，但是前者从左往右填充结构位字段。请为 Klinkerbell 计算机创建一个相应的位字段模板。
（在位字段的定义中，对于位使用的存储位数，使用未命名的字段宽度来进行填充。从右向左填充和从左向右填充在定义位字段时顺序相反。）
```c
struct Tinkerbell_driver {
    unsigned int fd_num : 2;    // 软盘
    unsigned int            : 1;
    unsigned int cd_num : 2;    // CD-ROM
    unsigned int            : 1;
    unsigned int hd_num : 2;    // 硬盘
};

struct Klinkerbell_driver {
    unsigned int hd_num : 2;    // 硬盘
    unsigned int : 1;
    unsigned int cd_num : 2;    // CD-ROM
    unsigned int       : 1
    unsigned int fd_num : 2;    // 软盘
};
```